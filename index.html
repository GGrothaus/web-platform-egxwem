<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
</style>
</head>
<body> 
<script type="module">

// import the Three.js module:
import * as THREE from "https://unpkg.com/three@0.126.0/build/three.module.js";
// load in the module:
import Stats from "https://unpkg.com/three@0.126.0/examples/jsm/libs/stats.module";

// add a stats view to the page to monitor performance:
const stats = new Stats();
document.body.appendChild(stats.dom);

function main() {
  const canvas = document.querySelector('#c');
  // create a renderer with better than default quality:
  const renderer = new THREE.WebGLRenderer({  antialias: true }); //alpha: true for white background
  renderer.setPixelRatio(window.devicePixelRatio);
  // make it fill the page
  renderer.setSize(window.innerWidth, window.innerHeight);
  // create and add the <canvas>
  document.body.appendChild(renderer.domElement); 
  const fov = 75; // this camera has a 75 degree field of view in the vertical axis
  const aspect = window.innerWidth / window.innerHeight; // the aspect ratio matches the size of the window
  //defining the near and far clipping planes (next two lines):
  const near = 0.05; // anything less than 5 centimeters from the eye will not be drawn
  const far = 100; // anything more than 100 meters from the eye will not be drawn
  const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
  camera.position.z = 2;
  camera.position.y = 0.5; //1.5 is approx average human eye height

  const scene = new THREE.Scene();

  //add geometric forms
  const geometry = new THREE.TorusKnotGeometry( 0.5, 0.2, 100, 16 );
  const geometry2 = new THREE.TorusKnotGeometry(0.2, 0.08, 16 , 100); 
  const geometry3 = new THREE.TorusKnotGeometry(0.4, 0.15, 100, 16);
  //const geometry3 = new THREE.ParametricGeometry( THREE.ParametricGeometries.klein, 25, 25 );
  //const geometry3 = new THREE.RingGeometry( 1, 5, 32 );
  const forms = [];  // an array to use to rotate the tori & other geometries

  const loader = new THREE.TextureLoader();
  const material = new THREE.MeshBasicMaterial({
    map: loader.load('https://threejsfundamentals.org/threejs/resources/images/wall.jpg'),
  //  map: loader.load('https://flic.kr/p/2ms1mta'), //learn why this isn't working
  });
  //const material2 = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
  //const material = new THREE.MeshBasicMaterial( { color: 0xffff00, side: THREE.DoubleSide } );

  const torus = new THREE.Mesh(geometry, material);
  const torus2 = new THREE.Mesh(geometry2, material);
  const torus3 = new THREE.Mesh(geometry3, material);
  //const klein = new THREE.Mesh(geometry3, material2);
  //const mesh = new THREE.Mesh(geometry3, material);

  scene.add(torus);
  scene.add(torus2);
  scene.add(torus3);
  //scene.add(klein);
  //scene.add(mesh);
  forms.push(torus, torus2, torus3);  // push to list of geometries to rotate
  torus.position.set(0.1, -0.1, 0.2);
  torus2.position.set(-0.7, 1.2, 0.2);
  torus3.position.set(2.9, 1.5, -5);

  function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }

  function render(time) {
    time *= 0.001;
    stats.begin()

    if (resizeRendererToDisplaySize(renderer)) {
      const canvas = renderer.domElement;
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    }

    forms.forEach((torus, ndx) => {
      const speed = .15 + ndx * .1;
      const rot = time * speed;
      torus.rotation.x = rot;
      torus.rotation.y = rot;
      torus2.rotation.x = rot*4;
      torus2.rotation.y = rot*2;
      torus3.rotation.x = rot*8;
      torus3.rotation.y = rot*12;

    });
    renderer.render(scene, camera);
    stats.end()
    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
}

main();


</script>
</body>

</html>