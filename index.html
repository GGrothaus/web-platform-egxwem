<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
</style>
</head>
<body>
<script type="module">

// import the Three.js module:
import * as THREE from "https://unpkg.com/three@0.126.0/build/three.module.js";
// load in the module:
import Stats from "https://unpkg.com/three@0.126.0/examples/jsm/libs/stats.module";

// add a stats view to the page to monitor performance:
const stats = new Stats();
document.body.appendChild(stats.dom);

// create a renderer with better than default quality:
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
// make it fill the page
renderer.setSize(window.innerWidth, window.innerHeight);
// create and add the <canvas>
document.body.appendChild(renderer.domElement); 

function main() {
  const canvas = document.querySelector('#c');
  const fov = 75; // this camera has a 75 degree field of view in the vertical axis
  const aspect = window.innerWidth / window.innerHeight; // the aspect ratio matches the size of the window
  //defining the near and far clipping planes (next two lines):
  const near = 0.05; // anything less than 5 centimeters from the eye will not be drawn
  const far = 100; // anything more than 100 meters from the eye will not be drawn
  const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
  camera.position.z = 2;
  camera.position.y = 0.5; //1.5 is approx average human eye height

  const scene = new THREE.Scene();

  const geometry = new THREE.TorusKnotGeometry( .5, .2, 100, 16 );
  const geometry2 = new THREE.TorusKnotGeometry(.1, .05, 100, 16); 
  const forms = [];  // just an array we can use to rotate the tori
  const loader = new THREE.TextureLoader();

  const material = new THREE.MeshBasicMaterial({
    map: loader.load('https://threejsfundamentals.org/threejs/resources/images/wall.jpg'),
  //  map: loader.load('https://flic.kr/p/2ms1mta'), //learn why this isn't working
  });
  const torus = new THREE.Mesh(geometry, material);
  const torus2 = new THREE.Mesh(geometry, material);
  scene.add(torus);
  scene.add(torus2);
  forms.push(torus, torus2);  // add to our list of cubes to rotate
  torus.position.set(0.1, -0.5, 0.2);
  torus2.position.set(-0.7, 1, 0.2);

  function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }

  function render(time) {
    time *= 0.001;
    stats.begin()

    if (resizeRendererToDisplaySize(renderer)) {
      const canvas = renderer.domElement;
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    }

    forms.forEach((torus, ndx) => {
      const speed = .15 + ndx * .1;
      const rot = time * speed;
      torus.rotation.x = rot;
      torus.rotation.y = rot;
      torus2.rotation.x = rot*4;

    });
    renderer.render(scene, camera);
    stats.end()
    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
}

main();


</script>
</body>

</html>